apply plugin: 'com.android.application'

def javaVersion = JavaVersion.VERSION_1_7
//指定基准文件保存位置
def bakPath = file("${buildDir}/bakpath");

android {
    signingConfigs {
        release {
            try {
                storeFile file('/Users/yanguoqing/Projects/Tinker/app/release.keystore')
                storePassword STORE_PASSWORD
                keyAlias = KEYALIAS
                keyPassword KEY_PASSWORD
            } catch (ex) {
                throw new InvalidUserDataException(ex.toString())
            }
        }
    }
    compileSdkVersion 29
    buildToolsVersion "29.0.3"
    compileOptions{
        sourceCompatibility javaVersion
        targetCompatibility javaVersion
    }

    defaultConfig {
        applicationId "com.anber.tinker"
        minSdkVersion 16
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"

        multiDexEnabled true
        /*multiDexKeepProguard file("tinker_multidexkeep.pro")

        buildConfigField "String", "MESSAGE", "\"I am the base apk\""
//        buildConfigField "String", "MESSAGE", "\"I am the patch apk\""
        *//**
         * client version would update with patch
         * so we can get the newly git version easily!
         *//*
        buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
        buildConfigField "String", "PLATFORM", "\"all\""*/

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }

    //真正的多渠道脚本支持
    flavorDimensions "version"
    productFlavors {

        googleplayer {
            dimension "version"
            applicationIdSuffix ".googleplayer"
            versionNameSuffix "-googleplayer"
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "googleplayer"]
        }

        baidu {
            dimension "version"
            applicationIdSuffix ".baidu"
            versionNameSuffix "-baidu"
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "baidu"]
        }

        productFlavors.all {
            flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
        }
    }

    sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
        }
    }

   /* packagingOptions {
        exclude "/META-INF/**"
    }*/
    //recommend
    dexOptions {
        jumboMode = true
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    //noinspection GradleCompatible
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    //noinspection GradleCompatible
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    api("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}")

    // Maven local cannot handle transist dependencies.
    implementation("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}")

    annotationProcessor("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}")
    compileOnly("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}")

    implementation "androidx.multidex:multidex:2.0.1"

    implementation 'androidx.annotation:annotation:1.0.0'

    implementation'com.squareup.okhttp3:okhttp:3.3.0' //okttp依赖

    implementation 'de.hdodenhof:circleimageview:2.1.0'
    implementation 'com.readystatesoftware.systembartint:systembartint:1.0.3'
    implementation 'com.google.code.gson:gson:2.8.6'
}

ext{
    //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?
    tinkerEnable = true;
    tinkerOldApkPath = "${bakPath}/app-0325-10-40-41"
    tinkerApplyMappingPath = "${bakPath}/app-0325-10-40-41"
    tinkerApplyResourceMappingPath = "${bakPath}/app-0325-10-40-41"
    tinkerBuildFlavorDirectory = "${bakPath}/app-0325-10-40-41"
    tinkerId = "1.0"
}

def buildWithTinker(){
    return ext.tinkerEnable
}

def getOldApkPath(){
    return ext.tinkerOldApkPath
}

def getApplyMappingPath(){
    return ext.tinkerApplyMappingPath;
}
def getApplyResourceMappingPath(){
    return ext.tinkerApplyResourceMappingPath
}
def getTinkerIdValue(){
    return ext.tinkerId;
}
def getTinkerBuildFlavorDirectory(){

    return ext.tinkerBuildFlavorDirectory
}

if (buildWithTinker()){
    //apply tinker插件
    apply plugin: 'com.tencent.tinker.patch'
    //所有tinker相关的配置
    tinkerPatch{
        //指定old apk 文件路径
        oldApk = getOldApkPath()
        //不忽略tinker警告，有则终止patch文件生成
        ignoreWarning =false
        //在运行过程中，我们需要验证基准apk包与补丁包的签名是否一致，我们是否需要为你签名。
        useSign = true
        //是否打开tinker的功能。
        tinkerEnable = buildWithTinker()

        buildConfig{
            //在编译新的apk时候，我们希望通过保持旧apk的proguard混淆方式，从而减少补丁包的大小。这个只是推荐设置，不设置applyMapping也不会影响任何的assemble编译。
            applyMapping = getApplyMappingPath()
            //在编译新的apk时候，我们希望通过旧apk的R.txt文件保持ResId的分配，这样不仅可以减少补丁包的大小，同时也避免由于ResId改变导致remote view异常
            applyResourceMapping = getApplyResourceMappingPath()
            //在运行过程中，我们需要验证基准apk包的tinkerId是否等于补丁包的tinkerId。这个是决定补丁包能运行在哪些基准包上面，一般来说我们可以使用git版本号、versionName等等
            tinkerId = getTinkerIdValue()
            //如果我们有多个dex,编译补丁时可能会由于类的移动导致变更增多。若打开keepDexApply模式，补丁包将根据基准包的类分布来编译
            keepDexApply = false
        }
        dex{
            //只能是'raw'或者'jar'。
            //对于'raw'模式，我们将会保持输入dex的格式。
            //对于'jar'模式，我们将会把输入dex重新压缩封装到jar。如果你的minSdkVersion小于14，你必须选择‘jar’模式
            // ，而且它更省存储空间，但是验证md5时比'raw'模式耗时。默认我们并不会去校验md5,一般情况下选择jar模式即可
            dexMode = "jar"
            //	需要处理dex路径，支持*、?通配符，必须使用'/'分割。路径是相对安装包的，例如assets/...
            pattern = ["classes*.dex",
                       "assets/secondary-dex-?.jar"]
            //这一项非常重要，它定义了哪些类在加载补丁包的时候会用到。这些类是通过Tinker无法修改的类，也是一定要放在main dex的类。
            //这里需要定义的类有：
            //1. 你自己定义的Application类；
            //2. Tinker库中用于加载补丁包的部分类，即com.tencent.tinker.loader.*；
            //3. 如果你自定义了TinkerLoader，需要将它以及它引用的所有类也加入loader中；
            //4. 其他一些你不希望被更改的类，例如Sample中的BaseBuildInfo类。这里需要注意的是，这些类的直接引用类也需要加入到loader中。或者你需要将这个类变成非preverify。
            //5. 使用1.7.6版本之后的gradle版本，参数1、2会自动填写。若使用newApk或者命令行版本编译，1、2依然需要手动填写
            loader = [
                    //use sample, let BaseBuildInfo unchangeable with tinker
                    "com.abner.tinker.MyTinkerApplication"
            ]
        }
        lib {
            //需要处理lib路径，支持*、?通配符，必须使用'/'分割。与dex.pattern一致, 路径是相对安装包的，例如assets/...
            pattern = ["lib/*/*.so"]
        }

        res {
            //需要处理res路径，支持*、?通配符，必须使用'/'分割。与dex.pattern一致, 路径是相对安装包的，
            // 例如assets/...，务必注意的是，只有满足pattern的资源才会放到合成后的资源包。
            pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]

            //支持*、?通配符，必须使用'/'分割。若满足ignoreChange的pattern，在编译时会忽略该文件的新增、删除与修改。
            //最极端的情况，ignoreChange与上面的pattern一致，即会完全忽略所有资源的修改。
            ignoreChange = ["assets/sample_meta.txt"]

            //对于修改的资源，如果大于largeModSize，我们将使用bsdiff算法。这可以降低补丁包的大小，
            // 但是会增加合成时的复杂度。默认大小为100kb
            largeModSize = 100
        }

        packageConfig {
            //configField("key", "value"), 默认我们自动从基准安装包与新安装包的Manifest中读取tinkerId,
            // 并自动写入configField。在这里，你可以定义其他的信息，
            // 在运行时可以通过TinkerLoadResult.getPackageConfigByName得到相应的数值。
            // 但是建议直接通过修改代码来实现，例如BuildConfig。
            configField("patchMessage", "tinker fix some bugs")
            /**
             * just a sample case, you can use such as sdkVersion, brand, channel...
             * you can parse it in the SamplePatchListener.
             * Then you can use patch conditional!
             */
            configField("platform", "all")
            /**
             * patch version via packageConfig
             */
            configField("patchVersion", "1.0")
        }
    }
    //==================================================
    List<String> flavors = new ArrayList<>();
    project.android.productFlavors.each { flavor ->
        flavors.add(flavor.name)
    }
    boolean hasFlavors = flavors.size() > 0
    def date = new Date().format("MMdd-HH-mm-ss")

    /**
     * bak apk and mapping
     */
    android.applicationVariants.all { variant ->
        /**
         * task type, you want to bak
         */
        def taskName = variant.name

        tasks.all {
            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {

                it.doLast {
                    copy {
                        def fileNamePrefix = "${project.name}-${variant.baseName}"
                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"

                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath

                        if (variant.metaClass.hasProperty(variant, 'packageApplicationProvider')) {
                            def packageAndroidArtifact = variant.packageApplicationProvider.get()
                            if (packageAndroidArtifact != null) {
                                try {
                                    from new File(packageAndroidArtifact.outputDirectory.getAsFile().get(), variant.outputs.first().apkData.outputFileName)
                                } catch (Exception e) {
                                    from new File(packageAndroidArtifact.outputDirectory, variant.outputs.first().apkData.outputFileName)
                                }
                            } else {
                                from variant.outputs.first().mainOutputFile.outputFile
                            }
                        } else {
                            from variant.outputs.first().outputFile
                        }

                        into destPath
                        rename { String fileName ->
                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
                        }

                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
                        from "${buildDir}/outputs/mapping/${variant.flavorName}Release/mapping.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
                        }

                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
                        from "${buildDir}/intermediates/symbol_list/${variant.dirName}/R.txt"
                        from "${buildDir}/intermediates/runtime_symbol_list/${variant.dirName}/R.txt"
                        from "${buildDir}/intermediates/runtime_symbol_list/${variant.flavorName}Release/R.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
                        }
                    }
                }
            }
        }
    }

    project.afterEvaluate {
        //sample use for build all flavor for one time
        if (hasFlavors) {
            task(tinkerPatchAllFlavorRelease) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"

                    }

                }
            }

            task(tinkerPatchAllFlavorDebug) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
                    }

                }
            }
        }
    }
}
